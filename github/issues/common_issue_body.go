package issues

import (
	// Stdlib
	"bytes"
	"fmt"
	"io"
	"regexp"
)

// ReviewIssueCommonBody represents the issue body part that is shared by all issue types,
// i.e. by both story review issues and commit review issues.
type ReviewIssueCommonBody struct {
	*CommitList
	*ReviewBlockerList

	UserContent string
}

func newReviewIssueCommonBody() *ReviewIssueCommonBody {
	return &ReviewIssueCommonBody{
		CommitList:        &CommitList{},
		ReviewBlockerList: &ReviewBlockerList{},
	}
}

// Formatting ------------------------------------------------------------------

const userContentSeparator = "----------"

var reviewIssueCommonBodyTemplate = fmt.Sprintf(`The commits to be reviewed are following:
{{range .CommitList.CommitItems}}- {{if .Reviewed}}[x]{{else}}[ ]{{end}} {{.CommitSHA}}: {{.CommitTitle}}
{{end}}
{{with .ReviewBlockerList.ReviewBlockerItems}}The following review blockers were opened by the reviewer:{{range .}}
- {{if .Fixed}}[x]{{else}}[ ]{{end}} [blocker {{.BlockerNumber}}]({{.CommentURL}}) (commit {{.CommitSHA}}): {{.BlockerSummary}}{{end}}
{{end}}
%v
{{if .UserContent}}{{.UserContent}}{{else}}
The content above was generated by SalsaFlow.
You can insert custom description here, but not above the separator.
{{end}}`, userContentSeparator)

func (body *ReviewIssueCommonBody) execTemplate(w io.Writer) {
	execTemplate(w, "review issue common body", reviewIssueCommonBodyTemplate, body)
}

// Parsing ---------------------------------------------------------------------

var (
	commonBodyCommitItemRegexp  = regexp.MustCompile(`^- \[([ xX])\] ([0-9a-f]+): (.+)$`)
	commonBodyBlockerItemRegexp = regexp.MustCompile(`^- \[([ xX])\] \[blocker ([0-9]+)\]\(([^)]+)\) \(commit ([0-9a-f]+)\): (.+)$`)
)

func parseRemainingIssueBody(err *error, scanner *bodyScanner) *ReviewIssueCommonBody {
	// For optimization.
	if *err != nil {
		return nil
	}

	// Parse the review issue common body part.
	// We pass a pointer to error to the parsing functions,
	// so in case there is an error, it just falls through
	// so that the error value can be checked at the very end.
	//
	// Also in case the user content separator is encountered,
	// it falls through and the user content is collected at the end.

	// Parse the commit list.
	commitList := parseCommonBodyCommitList(err, scanner)

	// An empty line follows. It is already set as the current line
	// in the scanner since that is what marks the end of the commit list.

	// Parse the review blocker list.
	reviewBlockerList := parseCommonBodyBlockerList(err, scanner)

	// And empty line follows. It is already set as the current line
	// in the scanner since that is what marks the end of the blocker list.

	// Parse the user content separator.
	readCommonBodySeparator(err, scanner)

	// Parse user content.
	userContent := parseCommonBodyUserContent(err, scanner)

	// Check for errors, but ignore io.EOF since that is ok.
	// The parsing functions return some reasonable empty values
	// even when there is an error.
	if ex := *err; ex != nil {
		if ex != io.EOF {
			return nil
		}
		*err = nil
	}

	// Return the common body object on success.
	return &ReviewIssueCommonBody{
		CommitList:        commitList,
		ReviewBlockerList: reviewBlockerList,
		UserContent:       userContent,
	}
}

func parseCommonBodyCommitList(err *error, scanner *bodyScanner) *CommitList {
	emptyList := &CommitList{}

	if *err != nil {
		return emptyList
	}

	// Read the list heading.
	_, _, ex := scanner.ReadLine()
	if ex != nil {
		*err = ex
		return emptyList
	}

	// Read the list items.
	commitList := &CommitList{}
	for {
		// Read the next line.
		line, _, ex := scanner.ReadLine()
		if ex != nil {
			*err = ex
			return commitList
		}

		// In case this is an empty line, we are done.
		if line == "" || line == userContentSeparator {
			return commitList
		}

		// Parse the line as a commit item.
		match := commonBodyCommitItemRegexp.FindStringSubmatch(line)
		if len(match) == 0 {
			*err = scanner.CurrentLineInvalid()
			return commitList
		}

		// Add the commit to the commit list.
		reviewed := match[1] != " "
		commitSHA, commitTitle := match[2], match[3]
		commitList.AddCommit(reviewed, commitSHA, commitTitle)
	}
}

func parseCommonBodyBlockerList(err *error, scanner *bodyScanner) *ReviewBlockerList {
	emptyList := &ReviewBlockerList{}

	if *err != nil {
		return emptyList
	}

	// Check the current line for the user content separator.
	line, _, _ := scanner.CurrentLine()
	if line == userContentSeparator {
		return emptyList
	}

	// Drop the list heading line.
	// We can be reading the user content separator here as well.
	line, _, ex := scanner.ReadLine()
	if ex != nil {
		*err = ex
		return emptyList
	}
	if line == userContentSeparator {
		return emptyList
	}

	// Read the list items.
	reviewBlockerList := &ReviewBlockerList{}
	for {
		// Read the next line.
		line, _, ex := scanner.ReadLine()
		if ex != nil {
			*err = ex
			return reviewBlockerList
		}

		// In case this is an empty line, we are done.
		if line == "" || line == userContentSeparator {
			return reviewBlockerList
		}

		// Parse the line as a review blocker item.
		match := commonBodyBlockerItemRegexp.FindStringSubmatch(line)
		if len(match) == 0 {
			*err = scanner.CurrentLineInvalid()
			return reviewBlockerList
		}

		// Add the blocker to the blocker list.
		fixed := match[1] != " "
		commentURL, commitSHA, blockerSummary := match[3], match[4], match[5]
		reviewBlockerList.AddReviewBlocker(fixed, commentURL, commitSHA, blockerSummary)
	}
}

func readCommonBodySeparator(err *error, scanner *bodyScanner) {
	if *err != nil {
		return
	}

	// Check the current line for the user content separator.
	if line, _, _ := scanner.CurrentLine(); line == userContentSeparator {
		return
	}

	// Read the input until the separator is encountered.
	// We can read the whole input here, but that is ok.
	// ReadLine returns io.EOF in that case and we return.
	for {
		line, _, ex := scanner.ReadLine()
		if ex != nil {
			*err = ex
			return
		}

		if line == userContentSeparator {
			return
		}
	}
}

func parseCommonBodyUserContent(err *error, scanner *bodyScanner) string {
	if *err != nil {
		return ""
	}

	// Prepare a buffer for the user content.
	buffer := bytes.NewBuffer(nil)

	writeLine := func(line string) {
		buffer.WriteString("\n")
		buffer.WriteString(line)
	}

	// Read the user content.
	// Make sure there is a single leading empty line.
	droppingEmptyLines := true
	for {
		line, _, ex := scanner.ReadLine()
		switch ex {
		case nil:
			// Drop leading empty lines.
			if droppingEmptyLines {
				if line == "" {
					continue
				}
				droppingEmptyLines = false
			}

			// Write the user content.
			writeLine(line)

		case io.EOF:
			// In case the error is io.EOF, we are done.
			return buffer.String()

		default:
			// Otherwise return the error.
			*err = ex
			return ""
		}
	}
}
